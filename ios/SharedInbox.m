// GENERATED BY app.shared-inbox.plugin.js (v3-auth-token+logging)
#import <Foundation/Foundation.h>
#import <React/RCTBridgeModule.h>

@interface SharedInbox : NSObject <RCTBridgeModule>
@end

@implementation SharedInbox
RCT_EXPORT_MODULE();

static NSString *const kInboxKey = @"SHARED_INBOX_ITEMS";
static NSString *const kAuthKey  = @"SHARED_INBOX_AUTH"; // { token: string, exp: number(ms) }

/** 受け取り箱に追加 */
RCT_EXPORT_METHOD(save:(NSString *)groupId
                  item:(NSDictionary *)item
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  NSLog(@"[SharedInbox native] save group=%@ item=%@", groupId, item);
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }

  @try {
    NSMutableArray *arr = [NSMutableArray arrayWithArray:[ud arrayForKey:kInboxKey] ?: @[]];
    NSMutableDictionary *mut = [item mutableCopy];
    if (!mut[@"ts"]) {
      long long ms = (long long)([[NSDate date] timeIntervalSince1970] * 1000.0);
      mut[@"ts"] = @(ms);
    }
    [arr addObject:mut];
    [ud setObject:arr forKey:kInboxKey];
    BOOL ok = [ud synchronize];
    NSLog(@"[SharedInbox native] saved ok=%d currentCount=%lu", ok, (unsigned long)arr.count);
    resolve(@(ok));
  } @catch (NSException *ex) {
    NSLog(@"[SharedInbox native] EXCEPTION %@", ex);
    reject(@"save_exception", ex.reason, nil);
  }
}

/** 受け取り箱を読み出して空にする */
RCT_EXPORT_METHOD(readAndClear:(NSString *)groupId
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  NSLog(@"[SharedInbox native] readAndClear group=%@", groupId);
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }

  @try {
    NSArray *arr = [ud arrayForKey:kInboxKey] ?: @[];
    [ud setObject:@[] forKey:kInboxKey];
    BOOL ok = [ud synchronize];
    NSLog(@"[SharedInbox native] readAndClear done ok=%d returned=%lu", ok, (unsigned long)arr.count);
    resolve(arr);
  } @catch (NSException *ex) {
    NSLog(@"[SharedInbox native] EXCEPTION %@", ex);
    reject(@"read_exception", ex.reason, nil);
  }
}

/** ★ IDトークンを保存（expはms epoch） */
RCT_EXPORT_METHOD(setAuthToken:(NSString *)groupId
                  token:(NSString *)token
                  expMs:(nonnull NSNumber *)expMs
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  NSLog(@"[SharedInbox native] setAuthToken group=%@ hasToken=%@", groupId, token.length > 0 ? @"YES" : @"NO");
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }
  @try {
    NSDictionary *obj = token ? @{ @"token": token, @"exp": expMs } : @{};
    [ud setObject:obj forKey:kAuthKey];
    BOOL ok = [ud synchronize];
    resolve(@(ok));
  } @catch (NSException *ex) {
    reject(@"auth_set_exception", ex.reason, nil);
  }
}

/** ★ IDトークンを取得 */
RCT_EXPORT_METHOD(getAuthToken:(NSString *)groupId
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }
  @try {
    NSDictionary *obj = [ud dictionaryForKey:kAuthKey] ?: @{};
    resolve(obj);
  } @catch (NSException *ex) {
    reject(@"auth_get_exception", ex.reason, nil);
  }
}

/** ★ IDトークンを削除（任意） */
RCT_EXPORT_METHOD(clearAuthToken:(NSString *)groupId
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }
  @try {
    [ud removeObjectForKey:kAuthKey];
    BOOL ok = [ud synchronize];
    resolve(@(ok));
  } @catch (NSException *ex) {
    reject(@"auth_clear_exception", ex.reason, nil);
  }
}

@end
