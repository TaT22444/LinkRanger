// app.shared-inbox.plugin.js － 最終版（ObjCはここで自動生成・上書き）
const { withXcodeProject, withDangerousMod } = require('@expo/config-plugins');
const fs = require('fs');
const path = require('path');

const TARGET_NAME = 'WinkShareExtension';           // ← 拡張ターゲット名
const NATIVE_FILE = 'SharedInbox.m';
const OBJC_VERSION = 'v2-logging-safe-resolve';     // ← 変更検知用タグ

const OBJC_CODE = `// GENERATED BY app.shared-inbox.plugin.js (${OBJC_VERSION})
#import <Foundation/Foundation.h>
#import <React/RCTBridgeModule.h>

@interface SharedInbox : NSObject <RCTBridgeModule>
@end

@implementation SharedInbox
RCT_EXPORT_MODULE();

static NSString *const kInboxKey = @"SHARED_INBOX_ITEMS";

RCT_EXPORT_METHOD(save:(NSString *)groupId
                  item:(NSDictionary *)item
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  NSLog(@"[SharedInbox native] save group=%@ item=%@", groupId, item);
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }

  @try {
    NSMutableArray *arr = [NSMutableArray arrayWithArray:[ud arrayForKey:kInboxKey] ?: @[]];
    NSMutableDictionary *mut = [item mutableCopy];
    if (!mut[@"ts"]) {
      long long ms = (long long)([[NSDate date] timeIntervalSince1970] * 1000.0);
      mut[@"ts"] = @(ms);
    }
    [arr addObject:mut];
    [ud setObject:arr forKey:kInboxKey];
    BOOL ok = [ud synchronize];
    NSLog(@"[SharedInbox native] saved ok=%d currentCount=%lu", ok, (unsigned long)arr.count);
    resolve(@(ok));
  } @catch (NSException *ex) {
    NSLog(@"[SharedInbox native] EXCEPTION %@", ex);
    reject(@"save_exception", ex.reason, nil);
  }
}

RCT_EXPORT_METHOD(readAndClear:(NSString *)groupId
              resolver:(RCTPromiseResolveBlock)resolve
              rejecter:(RCTPromiseRejectBlock)reject)
{
  NSLog(@"[SharedInbox native] readAndClear group=%@", groupId);
  if (!groupId || groupId.length == 0) { reject(@"no_group", @"Invalid app group", nil); return; }
  NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupId];
  if (!ud) { reject(@"no_group", @"Invalid app group", nil); return; }

  @try {
    NSArray *arr = [ud arrayForKey:kInboxKey] ?: @[];
    [ud setObject:@[] forKey:kInboxKey];
    BOOL ok = [ud synchronize];
    NSLog(@"[SharedInbox native] readAndClear done ok=%d returned=%lu", ok, (unsigned long)arr.count);
    resolve(arr);
  } @catch (NSException *ex) {
    NSLog(@"[SharedInbox native] EXCEPTION %@", ex);
    reject(@"read_exception", ex.reason, nil);
  }
}
@end
`;

// ===== helpers =====
function findTargetByProductType(project, productType) {
  const section = project.pbxNativeTargetSection();
  for (const k in section) {
    const t = section[k]; if (typeof t !== 'object') continue;
    if ((t.productType || '').includes(productType)) {
      const name = String(t.name).replace(/"/g, '');
      return { uuid: k, name };
    }
  }
  return null;
}
function findTargetByName(project, name) {
  const section = project.pbxNativeTargetSection();
  for (const k in section) {
    const t = section[k]; if (typeof t !== 'object') continue;
    const n = String(t.name).replace(/"/g, ''); if (n === name) return { uuid: k, name: n };
  }
  return null;
}
function hasSourceInTarget(project, targetUuid, fileName) {
  const phase = project.pbxSourcesBuildPhaseObj(targetUuid);
  const files = phase?.files || [];
  return files.some((f) => String(f.comment) === `${fileName} in Sources`);
}
function getMainGroupUuid(project) {
  const first = project.getFirstProject()?.firstProject;
  return first?.mainGroup;
}
function addSourceToTarget(project, targetUuid, fileName, groupUuid) {
  if (hasSourceInTarget(project, targetUuid, fileName)) return;
  project.addSourceFile(fileName, { target: targetUuid }, groupUuid);
}

// ===== mods =====
const withSharedInboxFile = (config) =>
  withDangerousMod(config, ['ios', (cfg) => {
    const iosDir = cfg.modRequest.platformProjectRoot;
    const filePath = path.join(iosDir, NATIVE_FILE);
    const needWrite = !fs.existsSync(filePath) || fs.readFileSync(filePath, 'utf8') !== OBJC_CODE;
    if (needWrite) {
      fs.writeFileSync(filePath, OBJC_CODE);
      console.log(`[shared-inbox.plugin] wrote ${NATIVE_FILE} (${OBJC_VERSION})`);
    } else {
      console.log(`[shared-inbox.plugin] ${NATIVE_FILE} up-to-date (${OBJC_VERSION})`);
    }
    return cfg;
  }]);

const withSharedInboxXcode = (config) =>
  withXcodeProject(config, (cfg) => {
    const project = cfg.modResults;
    const mainGroupUuid = getMainGroupUuid(project);
    if (!mainGroupUuid) throw new Error('[shared-inbox.plugin] Could not resolve main PBXGroup UUID');

    // 本体アプリ
    const appTarget = findTargetByProductType(project, 'com.apple.product-type.application');
    if (appTarget) addSourceToTarget(project, appTarget.uuid, NATIVE_FILE, mainGroupUuid);
    else console.warn('[shared-inbox.plugin] App target not found');

    // Share Extension
    const extTarget = findTargetByName(project, TARGET_NAME) ||
                      findTargetByProductType(project, 'com.apple.product-type.app-extension');
    if (extTarget) addSourceToTarget(project, extTarget.uuid, NATIVE_FILE, mainGroupUuid);
    else console.warn(`[shared-inbox.plugin] Extension target "${TARGET_NAME}" not found`);

    return cfg;
  });

module.exports = (config) => {
  config = withSharedInboxFile(config);
  config = withSharedInboxXcode(config);
  return config;
};